# HONE Worker Function
def HONE_worker(adj_matrix, dim, iterations, tol, seed, dt, gamma, stream):
    """
    Harmonic Oscillator Network Embedding (HONE) worker function using overdamped dynamics with CUDA streams.
    """
    with stream:
        cp.random.seed(seed)
        positions = cp.random.rand(adj_matrix.shape[0], dim)
        velocities = cp.zeros_like(positions)

        def calculate_forces(positions):
            forces = cp.zeros_like(positions)
            for i in range(len(positions)):
                delta = positions - positions[i]
                distances = cp.linalg.norm(delta, axis=1)
                mask = distances > 1e-6  # Avoid division by zero
                forces[i] = cp.sum(adj_matrix[i, mask][:, None] * (delta[mask] / distances[mask, None]), axis=0)
            return forces

        for _ in range(iterations):
            forces = calculate_forces(positions)
            velocities = -forces / gamma
            new_positions = positions + velocities * dt

            total_movement = cp.sum(cp.linalg.norm(new_positions - positions, axis=1))
            if total_movement < tol:
                break
            positions = new_positions

        distances = cp.linalg.norm(positions[:, None] - positions[None, :], axis=2)
        return cp.asnumpy(positions), cp.asnumpy(distances)

# HONE Function
def HONE(G, dim=2, iterations=100, seed_ensemble=100, tol=1e-4, dt=0.01, gamma=1.0):
    """
    Harmonic Oscillator Network Embedding (HONE) using GPU-based overdamped dynamics.
    """
    adj_matrix = cp.asarray(nx.to_numpy_array(G, weight="weight"))
    if not nx.is_weighted(G):
        adj_matrix[adj_matrix > 0] = 1  # Treat unweighted network as binary weighted

    streams = [cp.cuda.Stream(non_blocking=True) for _ in range(seed_ensemble)]  # Non-blocking streams
    results = [None] * seed_ensemble  # Preallocate results array

    # CUDA kernel 동시 실행
    for seed, stream in zip(range(seed_ensemble), streams):
        results[seed] = HONE_worker(adj_matrix, dim, iterations, tol, seed, dt, gamma, stream)

    # 모든 CUDA 작업 완료 대기
    cp.cuda.Stream.null.synchronize()

    # 결과 정리
    ensemble_positions = [result[0] for result in results]
    distance_matrices = np.array([result[1] for result in results])

    return ensemble_positions, distance_matrices

# HNI Function
def HNI(distance_matrices):
    """
    Harmonic Network Inconsistency (HNI) calculation.
    Calculates variance for each node pair across ensembles and averages these variances.
    """
    pairwise_variances = np.var(distance_matrices, axis=0)  # Shape: (num_nodes, num_nodes)
    upper_tri_indices = np.triu_indices_from(pairwise_variances, k=1)
    upper_tri_variances = pairwise_variances[upper_tri_indices]
    return np.mean(upper_tri_variances)
